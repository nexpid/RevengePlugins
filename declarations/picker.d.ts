// Generated by dts-bundle-generator v9.5.1

declare module "@react-native-documents/picker" {
    /**
     * The result of calling {@link isKnownType}
     * */
    export type IsKnownTypeResponse = {
    	/**
    	 * On iOS, this is true if the type is known to the device. That means it can be used with the document picker to filter what files can be picked.
    	 * On Android, this is true if the internal mime type database contains the given value.
    	 * */
    	isKnown: boolean;
    	/**
    	 * the preferred filename extension for the given value, if any
    	 * */
    	preferredFilenameExtension: string | null;
    	/**
    	 * the mime type for the given value, if any
    	 * */
    	mimeType: string | null;
    	/**
    	 * the UTType identifier for the given value, if any
    	 * */
    	UTType: string | null;
    };
    export type IsKnownTypeOptions = {
    	/**
    	 * the kind of value you're passing
    	 * */
    	kind: "UTType" | "mimeType" | "extension";
    	/**
    	 * the value you're checking, for example: application/pdf, com.adobe.pdf, pdf
    	 * */
    	value: string;
    };
    /**
     *
     * Checks if the given value (which can be a file extension, UTType identifier or mime) is known to the system.
     * Also returns the mime type which you can use to filter files on Android.
     *
     * @group DocumentPicker
     * */
    export declare function isKnownType(options: IsKnownTypeOptions): IsKnownTypeResponse;
    export type NonEmptyArray<T> = [
    	T,
    	...Array<T>
    ];
    /**
     * If you've requested long-term access to a directory or file, this object will be returned in the response.
     * In order to access the same directory or file in the future, you must store the `bookmark` opaque string,
     * and then pass it to the document viewer if you want to preview the file.
     *
     * See the Document viewer source on how to retrieve the file from the bookmark, if you need to do that (advanced use case).
     * */
    export type BookmarkingResponse = {
    	bookmarkStatus: "success";
    	bookmark: string;
    } | {
    	bookmarkStatus: "error";
    	bookmarkError: string;
    };
    /**
     * @group pick() types
     */
    export type VirtualFileMeta = {
    	/**
    	 * The registered extension for the given MIME type. Note that some MIME types map to multiple extensions.
    	 *
    	 * This call will return the most common extension for the given MIME type.
    	 *
    	 * Example: `pdf`
    	 */
    	extension: string | null;
    	/**
    	 * The MIME type of the file. This is necessary to export the virtual file to a local file.
    	 *
    	 * Example: `application/pdf`
    	 */
    	mimeType: string;
    };
    /**
     * @group pick() types
     */
    export type DocumentPickerResponse = {
    	/**
    	 * The URI of the picked file. This is a percent-encoded `content://` uri (Android), or a `file://` uri (iOS).
    	 * */
    	uri: string;
    	/**
    	 * The name of the picked file, including the extension. It's very unlikely that it'd be `null` but in theory, it can happen.
    	 * */
    	name: string | null;
    	/**
    	 * Error in case the file metadata could not be obtained.
    	 * */
    	error: string | null;
    	/**
    	 * The MIME type of the picked file.
    	 * */
    	type: string | null;
    	/**
    	 * The "native" type of the picked file: on Android, this is the MIME type. On iOS, it is the UTType identifier.
    	 * */
    	nativeType: string | null;
    	/**
    	 * The size of the picked file in bytes.
    	 * */
    	size: number | null;
    	/**
    	 * Android: whether the file is a virtual file (such as Google docs or sheets). Will be `null` on pre-Android 7.0 devices. On iOS, it's always `false`.
    	 * */
    	isVirtual: boolean | null;
    	/**
    	 * Android: The target types the virtual file can be converted to. Useful for {@link keepLocalCopy}.
    	 * This field is only present if `isVirtual` is true, and only on Android 7.0+. Always `null` on iOS.
    	 * */
    	convertibleToMimeTypes: VirtualFileMeta[] | null;
    	/**
    	 * Android: Some document providers on Android (especially those popular in Asia, it seems)
    	 * do not respect the request for limiting selectable file types.
    	 * `hasRequestedType` will be false if the user picked a file that does not have one of the requested types.
    	 *
    	 * You need to do your own post-processing and display an error to the user if this is important to your app.
    	 *
    	 * Always `true` on iOS.
    	 * */
    	hasRequestedType: boolean;
    };
    /**
     * iOS only. Configure the transition style of the picker.
     * */
    export type TransitionStyle = "coverVertical" | "flipHorizontal" | "crossDissolve" | "partialCurl" | undefined;
    /**
     * iOS only. Configure the presentation style of the picker.
     * */
    type PresentationStyle$1 = "fullScreen" | "pageSheet" | "formSheet" | "overFullScreen" | undefined;
    /**
     * Indicates, for each Uri that was passed to {@link keepLocalCopy}, whether the local copy was successfully created or not.
     *
     * If the copy was successful, the status field is `success` and `localUri` contains the local Uri.
     * If the copy was not successful, the status field is `error` and `copyError` field contains the error message.
     * */
    export type LocalCopyResponse = {
    	status: "success";
    	sourceUri: string;
    	localUri: string;
    } | {
    	status: "error";
    	sourceUri: string;
    	copyError: string;
    };
    /**
     * Parameter of {@link keepLocalCopy}. Object type representing the file(s) whose copy should be kept in the app's storage.
     * */
    export type FileToCopy = {
    	/**
    	 * The uri to keep a local copy of. This would be a `content://` uri (Android), or a `file://` uri (iOS) that the user has previously picked.
    	 * */
    	uri: string;
    	/**
    	 * The name of the resulting file, with the file extension. You can use the `name` field from the response of the `pick()` method.
    	 *
    	 * Example: someFile.pdf
    	 *
    	 * */
    	fileName: string;
    	/**
    	 * Only for Android virtual files: the type of the file to export to. For example, `application/pdf` or `text/plain`.
    	 * Use one of the values from `convertibleToMimeTypes` from the response of the `pick()` method: {@link DocumentPickerResponse}.
    	 * */
    	convertVirtualFileToType?: string;
    };
    /**
     * options for {@link keepLocalCopy}
     *
     * */
    export type KeepLocalCopyOptions = {
    	files: NonEmptyArray<FileToCopy>;
    	destination: "cachesDirectory" | "documentDirectory";
    };
    /**
     * Result of the call to {@link keepLocalCopy}. Please note the promise always resolves, even if there was an error processing any uri(s) (as indicated by the `status` field, and `copyError` field).
     * */
    export type KeepLocalCopyResponse = NonEmptyArray<LocalCopyResponse>;
    /**
     * Makes the file available in the app's storage. The behavior is different on iOS and Android, and for simple use cases (such as uploading file to remote server), you may not need to call this method at all.
     *
     * On Android, it can be used to "convert" a `content://` Uri into a local file. It also "exports" virtual files (such as Google docs or sheets) into local files.
     *
     * However, note that for some use cases, such as uploading the picked file to a server, you may not need to call `keepLocalCopy` at all. React Native's `fetch` can handle `content://` uris.
     *
     * @group DocumentPicker
     * */
    export declare function keepLocalCopy(options: KeepLocalCopyOptions): Promise<KeepLocalCopyResponse>;
    declare const mimeTypes: Readonly<{
    	readonly allFiles: "*/*";
    	readonly audio: "audio/*";
    	readonly csv: readonly [
    		"text/csv",
    		"text/comma-separated-values"
    	];
    	readonly doc: "application/msword";
    	readonly docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    	readonly images: "image/*";
    	readonly pdf: "application/pdf";
    	readonly plainText: "text/plain";
    	readonly json: "application/json";
    	readonly ppt: "application/vnd.ms-powerpoint";
    	readonly pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation";
    	readonly video: "video/*";
    	readonly xls: "application/vnd.ms-excel";
    	readonly xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    	readonly zip: "application/zip";
    }>;
    declare const utis: Readonly<{
    	readonly allFiles: "public.item";
    	readonly audio: "public.audio";
    	readonly csv: "public.comma-separated-values-text";
    	readonly doc: "com.microsoft.word.doc";
    	readonly docx: "org.openxmlformats.wordprocessingml.document";
    	readonly images: "public.image";
    	readonly pdf: "com.adobe.pdf";
    	readonly plainText: "public.plain-text";
    	readonly json: "public.json";
    	readonly ppt: "com.microsoft.powerpoint.ppt";
    	readonly pptx: "org.openxmlformats.presentationml.presentation";
    	readonly video: "public.movie";
    	readonly xls: "com.microsoft.excel.xls";
    	readonly xlsx: "org.openxmlformats.spreadsheetml.sheet";
    	readonly zip: "public.zip-archive";
    }>;
    /**
     * @hidden
     * */
    export declare const types: Readonly<{
    	readonly allFiles: "*/*";
    	readonly audio: "audio/*";
    	readonly csv: readonly [
    		"text/csv",
    		"text/comma-separated-values"
    	];
    	readonly doc: "application/msword";
    	readonly docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    	readonly images: "image/*";
    	readonly pdf: "application/pdf";
    	readonly plainText: "text/plain";
    	readonly json: "application/json";
    	readonly ppt: "application/vnd.ms-powerpoint";
    	readonly pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation";
    	readonly video: "video/*";
    	readonly xls: "application/vnd.ms-excel";
    	readonly xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    	readonly zip: "application/zip";
    }> | Readonly<{
    	readonly allFiles: "public.item";
    	readonly audio: "public.audio";
    	readonly csv: "public.comma-separated-values-text";
    	readonly doc: "com.microsoft.word.doc";
    	readonly docx: "org.openxmlformats.wordprocessingml.document";
    	readonly images: "public.image";
    	readonly pdf: "com.adobe.pdf";
    	readonly plainText: "public.plain-text";
    	readonly json: "public.json";
    	readonly ppt: "com.microsoft.powerpoint.ppt";
    	readonly pptx: "org.openxmlformats.presentationml.presentation";
    	readonly video: "public.movie";
    	readonly xls: "com.microsoft.excel.xls";
    	readonly xlsx: "org.openxmlformats.spreadsheetml.sheet";
    	readonly zip: "public.zip-archive";
    }>;
    type ValuesOf<T> = T[keyof T];
    type Flatten<T> = T extends Array<infer U> ? U : T;
    type AllMimeTypes = Flatten<ValuesOf<typeof mimeTypes>>;
    type AllAppleUTIs = ValuesOf<typeof utis>;
    /**
     * You'd rarely use this type directly.
     * It represents the predefined file types which are exported as `types` and can be used to limit the kinds of files that can be picked.
     *
     * @example
     * ```ts
     * import {
     *   pick,
     *   types,
     * } from '@react-native-documents/picker'
     * // ...
     * const result = await pick({
     *   type: [types.pdf, types.docx],
     * })
     * ```
     * */
    export type PredefinedFileTypes = Flatten<AllMimeTypes> | AllAppleUTIs;
    interface NativeModuleError extends Error {
    	code: string;
    }
    /**
     * Error codes that can be returned by the module, and are available on the `code` property of the error.
     *
     * @example
     * ```ts
     *   const handleError = (err: unknown) => {
     *     if (isErrorWithCode(err)) {
     *       switch (err.code) {
     *         case errorCodes.IN_PROGRESS:
     *           ...
     *           break
     *         case errorCodes.UNABLE_TO_OPEN_FILE_TYPE:
     *           ...
     *           break
     *         case errorCodes.OPERATION_CANCELED:
     *           // ignore
     *           break
     *         default:
     *           console.error(err)
     *       }
     *     } else {
     *        console.error(err)
     *     }
     *   }
     * ```
     * */
    export declare const errorCodes: Readonly<{
    	OPERATION_CANCELED: "OPERATION_CANCELED";
    	IN_PROGRESS: "ASYNC_OP_IN_PROGRESS";
    	UNABLE_TO_OPEN_FILE_TYPE: "UNABLE_TO_OPEN_FILE_TYPE";
    }>;
    /**
     * TypeScript helper to check if an object has the `code` property.
     * This is used to avoid `as` casting when you access the `code` property on errors returned by the module.
     */
    export declare const isErrorWithCode: (error: any) => error is NativeModuleError;
    /**
     * Base options object for the directory picker. They only slightly influence the appearance of the picker modal on iOS.
     * You'd rarely use this type directly, but instead use {@link DirectoryPickerOptions}
     *
     * which extend this type
     * @group pickDirectory() types
     */
    export type DirectoryPickerOptionsBase = {
    	/**
    	 * iOS only - Controls how the picker is presented, e.g. on an iPad you may want to present it fullscreen. Defaults to `pageSheet`.
    	 * */
    	presentationStyle?: PresentationStyle$1;
    	/**
    	 * iOS only - Configures the transition style of the picker. Defaults to coverVertical, when the picker is presented, its view slides up from the bottom of the screen.
    	 * */
    	transitionStyle?: TransitionStyle;
    };
    /**
     * @hidden
     * */
    export type DirectoryPickerOptionsLongTerm = DirectoryPickerOptionsBase & {
    	requestLongTermAccess: true;
    };
    /**
     * Options for {@link pickDirectory}.
     *
     * @group pickDirectory() types
     * */
    export type DirectoryPickerOptions = DirectoryPickerOptionsBase & {
    	requestLongTermAccess: boolean;
    };
    /**
     * This object represents the response from the directory picker, when long-term access was not requested.
     *
     * @group pickDirectory() types
     * */
    export type DirectoryPickerResponse = {
    	/**
    	 * The (percent-encoded) directory selected by user.
    	 * */
    	uri: string;
    };
    /**
     * This object represents the response from the directory picker, when long-term access was requested.
     *
     * @group pickDirectory() types
     * */
    export type DirectoryPickerResponseLongTerm = DirectoryPickerResponse & BookmarkingResponse;
    /**
     * You likely won't use this type directly, but instead use {@link DirectoryPickerResponse} or {@link DirectoryPickerResponseLongTerm}.
     *
     * @group pickDirectory() types
     * */
    export type PickDirectoryResponse<O extends DirectoryPickerOptions> = Promise<O extends DirectoryPickerOptionsLongTerm ? DirectoryPickerResponseLongTerm : DirectoryPickerResponse>;
    /**
     * Opens a directory picker.
     *
     * @group DocumentPicker
     * */
    export declare function pickDirectory<O extends DirectoryPickerOptions>(options?: O): PickDirectoryResponse<O>;
    /**
     * Base options object for the document picker.
     * You'd rarely use this type directly, but instead use one of
     *
     * {@link DocumentPickerOptionsImport}, {@link DocumentPickerOptionsOpenOnce} or {@link DocumentPickerOptionsOpenLongTerm}
     *
     * which extend this type
     * @group pick() types
     */
    export type DocumentPickerOptionsBase = {
    	/**
    	 * Specify file type(s) that you want to pick. Use `types` for some predefined values.
    	 * */
    	type?: string | PredefinedFileTypes | Array<PredefinedFileTypes | string>;
    	/**
    	 * Whether to allow multiple files to be picked. False by default.
    	 * */
    	allowMultiSelection?: boolean;
    	/**
    	 * Android only - Whether to allow virtual files (such as Google docs or sheets) to be picked. False by default.
    	 * */
    	allowVirtualFiles?: boolean;
    	/**
    	 * iOS only - Controls how the picker is presented, e.g. on an iPad you may want to present it fullscreen. Defaults to `pageSheet`.
    	 * */
    	presentationStyle?: PresentationStyle$1;
    	/**
    	 * iOS only - Configures the transition style of the picker. Defaults to coverVertical, when the picker is presented, its view slides up from the bottom of the screen.
    	 * */
    	transitionStyle?: TransitionStyle;
    };
    /**
     * Present the document picker in import mode.
     *
     * @group pick() types
     */
    export type DocumentPickerOptionsImport = DocumentPickerOptionsBase & {
    	mode?: "import";
    	requestLongTermAccess?: never;
    };
    /**
     * Present the document picker in open mode, with permissions to access the file for a limited time (until the app terminates).
     *
     * @group pick() types
     */
    export type DocumentPickerOptionsOpenOnce = DocumentPickerOptionsBase & {
    	mode: "open";
    	requestLongTermAccess?: false;
    };
    /**
     * Present the document picker in open mode, with long-term permissions to access the opened file.
     *
     * @group pick() types
     */
    export type DocumentPickerOptionsOpenLongTerm = DocumentPickerOptionsBase & {
    	mode: "open";
    	requestLongTermAccess: true;
    };
    type DocumentPickerOptionsOpen = DocumentPickerOptionsOpenOnce | DocumentPickerOptionsOpenLongTerm;
    /**
     * @hidden
     */
    export type DocumentPickerOptions = DocumentPickerOptionsImport | DocumentPickerOptionsOpen;
    /**
     * The result of calling {@link pick} with `mode: 'open'` and `requestLongTermAccess: true`
     *
     * @group pick() types
     */
    export type DocumentPickerResponseOpenLongTerm = DocumentPickerResponse & BookmarkingResponse;
    type PickResponse<O extends DocumentPickerOptions> = Promise<O extends DocumentPickerOptionsOpenLongTerm ? NonEmptyArray<DocumentPickerResponseOpenLongTerm> : NonEmptyArray<DocumentPickerResponse>>;
    /**
     * The method for picking a file, both for `import` and `open` modes.
     *
     * For result types, see {@link DocumentPickerResponse} or {@link DocumentPickerResponseOpenLongTerm}.
     *
     * For options, see {@link DocumentPickerOptionsImport}, {@link DocumentPickerOptionsOpenOnce} or {@link DocumentPickerOptionsOpenLongTerm}.
     *
     * @group DocumentPicker
     * */
    export declare function pick<O extends DocumentPickerOptions>(options?: O): PickResponse<O>;
    /**
     * Options object for the {@link saveDocuments} method. `sourceUris` is the only required field.
     *
     * @group saveDocuments() types
     */
    export type SaveDocumentsOptions = {
    	/**
    	 * The source URIs of the files to save, percentage-encoded. Android only allows to save one file at a time, iOS allows multiple.
    	 * */
    	sourceUris: string[];
    	/**
    	 * Android-only: The MIME type of the file to be stored.
    	 * It is recommended to provide this value, otherwise the system will try to infer it from the sourceUri using ContentResolver.
    	 * */
    	mimeType?: string;
    	/**
    	 * Android-only: The suggested title of the file to be stored, which will be pre-filled in the UI.
    	 * On iOS, the target name is taken from the source uri, and is changeable only when exactly one file is being saved.
    	 * */
    	fileName?: string;
    	/**
    	 * iOS-only: Whether to copy the file to a new location, or move it (default).
    	 * On Android, file is always copied.
    	 * */
    	copy?: boolean;
    };
    /**
     * The result of calling {@link saveDocuments}. It is very unlikely that the metadata fields would be `null`, but in theory, it can happen.
     *
     * @group saveDocuments() types
     */
    export type SaveDocumentsResponse = {
    	/**
    	 * The target URI - the one user saved to. This is a percent-encoded `content://` uri (Android), or a `file://` uri (iOS).
    	 * */
    	uri: string;
    	/**
    	 * The name of the file that user entered, including extension.
    	 * */
    	name: string | null;
    	/**
    	 * Error in case the file could not be written or some metadata could not be obtained.
    	 * */
    	error: string | null;
    };
    /**
     * The method for opening a "save as" dialog and saving source file(s) to a new location.
     *
     * On Android, only one file can be saved at a time.
     *
     * @group DocumentPicker
     * */
    export declare function saveDocuments(options: SaveDocumentsOptions): Promise<NonEmptyArray<SaveDocumentsResponse>>;
    /**
     * For each uri whose release was requested, the result will contain an object with the uri and a status.
     * */
    export type ReleaseLongTermAccessResult = Array<{
    	uri: string;
    	status: "success";
    } | {
    	uri: string;
    	status: "error";
    	errorMessage: string;
    }>;
    /**
     * Android only - Releases long-term access to the given URIs. There's no need to call this method on iOS - there's no iOS equivalent.
     *
     * See [Android documentation](https://developer.android.com/reference/android/content/ContentResolver#releasePersistableUriPermission(android.net.Uri,%20int)) for more information.
     */
    export declare const releaseLongTermAccess: (uris: string[]) => Promise<ReleaseLongTermAccessResult>;
    /**
     * iOS only - Releases (stops) secure access to the given URIs. Use with URIs obtained with Open mode or with the Directory Picker.
     * See [iOS documentation](https://developer.apple.com/documentation/foundation/nsurl/1413736-stopaccessingsecurityscopedresou) for more information.
     * There's no need to call this method on Android - there's no equivalent method on Android.
     * */
    export declare const releaseSecureAccess: (uris: string[]) => Promise<null>;
    
    export {
    	PresentationStyle$1 as PresentationStyle,
    };
    
    export {};
};
