// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../react
//   ../../../../recyclerlistview
//   ../../../../react-native

declare module '@shopify/flash-list' {
	export { default as FlashList } from "@shopify/flash-list/FlashList";
	export { FlashListProps, ContentStyle, ListRenderItem, ListRenderItemInfo, RenderTarget, RenderTargetOptions, } from "@shopify/flash-list/FlashListProps";
	export { default as AnimatedFlashList } from "@shopify/flash-list/AnimatedFlashList";
	export { useOnNativeBlankAreaEvents, BlankAreaEventHandler, BlankAreaEvent, } from "@shopify/flash-list/native/auto-layout/AutoLayoutView";
	export { useBenchmark, BenchmarkParams, BenchmarkResult, } from "@shopify/flash-list/benchmark/useBenchmark";
	export { useDataMultiplier } from "@shopify/flash-list/benchmark/useDataMultiplier";
	export { useFlatListBenchmark, FlatListBenchmarkParams, } from "@shopify/flash-list/benchmark/useFlatListBenchmark";
	export { useBlankAreaTracker, BlankAreaTrackerResult, BlankAreaTrackerConfig, } from "@shopify/flash-list/benchmark/useBlankAreaTracker";
	export { MasonryFlashList, MasonryFlashListProps, MasonryFlashListScrollEvent, MasonryFlashListRef, MasonryListItem, MasonryListRenderItem, MasonryListRenderItemInfo, } from "@shopify/flash-list/MasonryFlashList";
	export { JSFPSMonitor, JSFPSResult } from "@shopify/flash-list/benchmark/JSFPSMonitor";
	export { autoScroll, Cancellable } from "@shopify/flash-list/benchmark/AutoScrollHelper";
	export { default as ViewToken } from "@shopify/flash-list/viewability/ViewToken";
	export { default as CellContainer } from "@shopify/flash-list/native/cell-container/CellContainer";
}

declare module '@shopify/flash-list/FlashList' {
	import React from "react";
	import { DataProvider, RecyclerListView, RecyclerListViewProps } from "recyclerlistview";
	import GridLayoutProviderWithProps from "@shopify/flash-list/GridLayoutProviderWithProps";
	import { FlashListProps } from "@shopify/flash-list/FlashListProps";
	export interface FlashListState<T> {
			dataProvider: DataProvider;
			numColumns: number;
			layoutProvider: GridLayoutProviderWithProps<T>;
			data?: ReadonlyArray<T> | null;
			extraData?: ExtraData<unknown>;
			renderItem?: FlashListProps<T>["renderItem"];
	}
	interface ExtraData<T> {
			value?: T;
	}
	class FlashList<T> extends React.PureComponent<FlashListProps<T>, FlashListState<T>> {
			static defaultProps: {
					data: never[];
					numColumns: number;
			};
			constructor(props: FlashListProps<T>);
			static getDerivedStateFromProps<T>(nextProps: Readonly<FlashListProps<T>>, prevState: FlashListState<T>): FlashListState<T>;
			componentDidMount(): void;
			componentWillUnmount(): void;
			render(): JSX.Element;
			/**
				* Disables recycling for the next frame so that layout animations run well.
				* Warning: Avoid this when making large changes to the data as the list might draw too much to run animations. Single item insertions/deletions
				* should be good. With recycling paused the list cannot do much optimization.
				* The next render will run as normal and reuse items.
				*/
			prepareForLayoutAnimationRender(): void;
			scrollToEnd(params?: {
					animated?: boolean | null | undefined;
			}): void;
			scrollToIndex(params: {
					animated?: boolean | null | undefined;
					index: number;
					viewOffset?: number | undefined;
					viewPosition?: number | undefined;
			}): void;
			scrollToItem(params: {
					animated?: boolean | null | undefined;
					item: any;
					viewPosition?: number | undefined;
					viewOffset?: number | undefined;
			}): void;
			scrollToOffset(params: {
					animated?: boolean | null | undefined;
					offset: number;
			}): void;
			getScrollableNode(): number | null;
			/**
				* Allows access to internal recyclerlistview. This is useful for enabling access to its public APIs.
				* Warning: We may swap recyclerlistview for something else in the future. Use with caution.
				*/
			get recyclerlistview_unsafe(): RecyclerListView<RecyclerListViewProps, any> | undefined;
			/**
				* Specifies how far the first item is from top of the list. This would normally be a sum of header size and top/left padding applied to the list.
				*/
			get firstItemOffset(): number;
			/**
				* FlashList will skip using layout cache on next update. Can be useful when you know the layout will change drastically for example, orientation change when used as a carousel.
				*/
			clearLayoutCacheOnUpdate(): void;
			/**
				* Tells the list an interaction has occurred, which should trigger viewability calculations, e.g. if waitForInteractions is true and the user has not scrolled.
				* This is typically called by taps on items or by navigation actions.
				*/
			recordInteraction: () => void;
	}
	export default FlashList;
}

declare module '@shopify/flash-list/FlashListProps' {
	import type React from "react";
	import { StyleProp, ScrollViewProps, ViewabilityConfig, ViewabilityConfigCallbackPairs, ViewStyle } from "react-native";
	import { BlankAreaEventHandler } from "@shopify/flash-list/native/auto-layout/AutoLayoutView";
	import ViewToken from "@shopify/flash-list/viewability/ViewToken";
	export interface ListRenderItemInfo<TItem> {
			item: TItem;
			index: number;
			/**
				* FlashList may render your items for multiple reasons.
				* Cell - This is for your list item
				* Measurement - Might be invoked for size measurement and won't be visible. You can ignore this in analytics.
				* StickyHeader - This is for your sticky header. Use this to change your item's appearance while it's being used as a sticky header.
				*/
			target: RenderTarget;
			extraData?: any;
	}
	export type RenderTarget = "Cell" | "StickyHeader" | "Measurement";
	export const RenderTargetOptions: Record<string, RenderTarget>;
	export type ListRenderItem<TItem> = (info: ListRenderItemInfo<TItem>) => React.ReactElement | null;
	export type ContentStyle = Pick<ViewStyle, "backgroundColor" | "paddingTop" | "paddingLeft" | "paddingRight" | "paddingBottom" | "padding" | "paddingVertical" | "paddingHorizontal">;
	export interface FlashListProps<TItem> extends ScrollViewProps {
			/**
				* Takes an item from `data` and renders it into the list. Typical usage:
				* ```ts
				* renderItem = ({item}) => (
				*   <Text>{item.title}</Text>
				* );
				* ...
				* <FlashList data={[{title: 'Title Text', key: 'item1'}]} renderItem={renderItem} />
				* ```
				*
				* Provides additional metadata like `index`
				*
				* - `item` (`Object`): The item from `data` being rendered.
				* - `index` (`number`): The index corresponding to this item in the `data` array.
				*/
			renderItem: ListRenderItem<TItem> | null | undefined;
			/**
				* For simplicity, data is a plain array of items of a given type.
				*/
			data: ReadonlyArray<TItem> | null | undefined;
			/**
				* Average or median size for elements in the list. Doesn't have to be very accurate but a good estimate can improve performance.
				* A quick look at `Element Inspector` can help you determine this. If you're confused between two values, the smaller value is a better choice.
				* For vertical lists provide average height and for horizontal average width.
				* Read more about it here: https://shopify.github.io/flash-list/docs/estimated-item-size
				*/
			estimatedItemSize?: number;
			/**
				* Each cell is rendered using this element.
				* Can be a React Component Class, or a render function.
				* The root component should always be a `CellContainer` which is also the default component used.
				* Ensure that the original `props` are passed to the returned `CellContainer`. The `props` will include the following:
				* - `onLayout`: Method for updating data about the real `CellContainer` layout
				* - `index`: Index of the cell in the list, you can use this to query data if needed
				* - `style`: Style of `CellContainer`, including:
				*   - `flexDirection`: Depends on whether your list is horizontal or vertical
				*   - `position`: Value of this will be `absolute` as that's how `FlashList` positions elements
				*   - `left`: Determines position of the element on x axis
				*   - `top`: Determines position of the element on y axis
				*   - `width`: Determines width of the element (present when list is vertical)
				*   - `height`: Determines height of the element (present when list is horizontal)
				*
				* Note: Changing layout of the cell can conflict with the native layout operations. You may need to set `disableAutoLayout` to `true` to prevent this.
				*/
			CellRendererComponent?: React.ComponentType<any> | undefined;
			/**
				* Rendered in between each item, but not at the top or bottom. By default, `leadingItem` and `trailingItem` (if available) props are provided.
				*/
			ItemSeparatorComponent?: React.ComponentType<any> | null | undefined;
			/**
				* Rendered when the list is empty. Can be a React Component (e.g. `SomeComponent`), or a React element (e.g. `<SomeComponent />`).
				*/
			ListEmptyComponent?: React.ComponentType<any> | React.ReactElement | null | undefined;
			/**
				* Rendered at the bottom of all the items. Can be a React Component (e.g. `SomeComponent`), or a React element (e.g. `<SomeComponent />`).
				*/
			ListFooterComponent?: React.ComponentType<any> | React.ReactElement | null | undefined;
			/**
				* Styling for internal View for `ListFooterComponent`.
				*/
			ListFooterComponentStyle?: StyleProp<ViewStyle> | undefined;
			/**
				* Rendered at the top of all the items. Can be a React Component (e.g. `SomeComponent`), or a React element (e.g. `<SomeComponent />`).
				*/
			ListHeaderComponent?: React.ComponentType<any> | React.ReactElement | null | undefined;
			/**
				* Styling for internal View for `ListHeaderComponent`.
				*/
			ListHeaderComponentStyle?: StyleProp<ViewStyle> | undefined;
			/**
				* Rendered as the main scrollview.
				*/
			renderScrollComponent?: React.ComponentType<ScrollViewProps> | React.FC<ScrollViewProps>;
			/**
				* You can use `contentContainerStyle` to apply padding that will be applied to the whole content itself.
				* For example, you can apply this padding, so that all of your items have leading and trailing space.
				*/
			contentContainerStyle?: ContentStyle;
			/**
				* Draw distance for advanced rendering (in dp/px)
				*/
			drawDistance?: number;
			/**
				* Specifies how far the first item is drawn from start of the list window or, offset of the first item of the list (not the header).
				* Needed if you're using initialScrollIndex prop. Before the initial draw the list cannot figure out the size of header or, any special margin/padding that might have been applied
				* using header styles etc.
				* If this isn't provided initialScrollIndex might not scroll to the provided index.
				*/
			estimatedFirstItemOffset?: number;
			/**
				* Visible height and width of the list. This is not the scroll content size.
				*/
			estimatedListSize?: {
					height: number;
					width: number;
			};
			/**
				* A marker property for telling the list to re-render (since it implements PureComponent).
				* If any of your `renderItem`, Header, Footer, etc. functions depend on anything outside of the `data` prop,
				* stick it here and treat it immutably.
				*/
			extraData?: any;
			/**
				* If true, renders items next to each other horizontally instead of stacked vertically.
				*/
			horizontal?: boolean | null | undefined;
			/**
				* Instead of starting at the top with the first item, start at initialScrollIndex.
				*/
			initialScrollIndex?: number | null | undefined;
			/**
				* Reverses the direction of scroll. Uses scale transforms of -1.
				*/
			inverted?: boolean | null | undefined;
			/**
				* Used to extract a unique key for a given item at the specified index.
				* Key is used for optimizing performance. Defining `keyExtractor` is also necessary
				* when doing [layout animations](https://shopify.github.io/flash-list/docs/guides/layout-animation)
				* to uniquely identify animated components.
				*/
			keyExtractor?: ((item: TItem, index: number) => string) | undefined;
			/**
				* Multiple columns can only be rendered with `horizontal={false}` and will zig-zag like a `flexWrap` layout.
				* Items should all be the same height - masonry layouts are not supported.
				*/
			numColumns?: number | undefined;
			/**
				* Computes blank space that is visible to the user during scroll or list load. If list doesn't have enough items to fill the screen even then this will be raised.
				* Values reported: {
				*    offsetStart -> visible blank space on top of the screen (while going up). If value is greater than 0 then it's visible to user.
				*    offsetEnd -> visible blank space at the end of the screen (while going down). If value is greater than 0 then it's visible to user.
				*    blankArea -> max(offsetStart, offsetEnd) use this directly and look for values > 0
				* }
				* Please note that this event isn't synced with onScroll event but works with native onDraw/layoutSubviews. Events with values > 0 are blanks.
				* This event is raised even when there is no visible blank with negative values for extensibility however, for most use cases check blankArea > 0 and use the value.
				*/
			onBlankArea?: BlankAreaEventHandler;
			/**
				* Called once when the scroll position gets within onEndReachedThreshold of the rendered content.
				*/
			onEndReached?: (() => void) | null | undefined;
			/**
				* How far from the end (in units of visible length of the list) the bottom edge of the
				* list must be from the end of the content to trigger the `onEndReached` callback.
				* Thus a value of 0.5 will trigger `onEndReached` when the end of the content is
				* within half the visible length of the list.
				*/
			onEndReachedThreshold?: number | null | undefined;
			/**
				* This event is raised once the list has drawn items on the screen. It also reports @param elapsedTimeInMs which is the time it took to draw the items.
				* This is required because FlashList doesn't render items in the first cycle. Items are drawn after it measures itself at the end of first render.
				* If you're using ListEmptyComponent, this event is raised as soon as ListEmptyComponent is rendered.
				*/
			onLoad?: (info: {
					elapsedTimeInMs: number;
			}) => void;
			/**
				* Called when the viewability of rows changes, as defined by the `viewabilityConfig` prop.
				* Array of `changed` includes `ViewToken`s that both visible and non-visible items. You can use the `isViewable` flag to filter the items.
				*
				* If you are tracking the time a view becomes (non-)visible, use the `timestamp` property.
				* We make no guarantees that in the future viewability callbacks will be invoked as soon as they happen - for example,
				* they might be deferred until JS thread is less busy.
				*/
			onViewableItemsChanged?: ((info: {
					viewableItems: ViewToken[];
					changed: ViewToken[];
			}) => void) | null | undefined;
			/**
				* If provided, a standard RefreshControl will be added for "Pull to Refresh" functionality.
				* Make sure to also set the refreshing prop correctly.
				*/
			onRefresh?: (() => void) | null | undefined;
			/**
				* Allows developers to override type of items. This will improve recycling if you have different types of items in the list
				* Right type will be used for the right item. Default type is 0
				* If you don't want to change for an indexes just return undefined.
				* Performance: This method is called very frequently. Keep it fast.
				*/
			getItemType?: (item: TItem, index: number, extraData?: any) => string | number | undefined;
			/**
				* This method can be used to provide explicit size estimates or change column span of an item.
				*
				* Providing specific estimates is a good idea when you can calculate sizes reliably. FlashList will prefer this value over `estimatedItemSize` for that specific item.
				* Precise estimates will also improve precision of `scrollToIndex` method and `initialScrollIndex` prop. If you have a `separator` below your items you can include its size in the estimate.
				*
				* Changing item span is useful when you have grid layouts (numColumns > 1) and you want few items to be bigger than the rest.
				*
				* Modify the given layout. Do not return. FlashList will fallback to default values if this is ignored.
				*
				* Performance: This method is called very frequently. Keep it fast.
				*/
			overrideItemLayout?: (layout: {
					span?: number;
					size?: number;
			}, item: TItem, index: number, maxColumns: number, extraData?: any) => void;
			/**
				* For debugging and exception use cases, internal props will be overriden with these values if used
				*/
			overrideProps?: object;
			/**
				* Set this when offset is needed for the loading indicator to show correctly.
				* @platform android
				*/
			progressViewOffset?: number | undefined;
			/**
				* Set this true while waiting for new data from a refresh.
				*/
			refreshing?: boolean | null | undefined;
			/**
				* `viewabilityConfig` is a default configuration for determining whether items are viewable.
				*
				* Changing viewabilityConfig on the fly is not supported.
				*/
			viewabilityConfig?: ViewabilityConfig | null | undefined;
			/**
				* List of `ViewabilityConfig`/`onViewableItemsChanged` pairs.
				* A specific `onViewableItemsChanged` will be called when its corresponding `ViewabilityConfig`'s conditions are met.
				*/
			viewabilityConfigCallbackPairs?: ViewabilityConfigCallbackPairs | undefined;
			/**
				* FlashList attempts to measure size of horizontal lists by drawing an extra list item in advance. This can sometimes cause issues when used with `initialScrollIndex` in lists
				* with very little content. You might see some amount of over scroll. When set to true the list's rendered size needs to be deterministic (i.e., height and width greater than 0)
				* as FlashList will skip rendering the extra item for measurement. Default value is `false`.
				*/
			disableHorizontalListHeightMeasurement?: boolean;
			/**
				* FlashList applies some fixes to layouts of its children which can conflict with custom `CellRendererComponent`
				* implementations. You can disable this behavior by setting this to `true`.
				* Recommendation: Set this to `true` while you apply special behavior to the `CellRendererComponent`. Once done set this to
				* `false` again.
				*/
			disableAutoLayout?: boolean;
	}
}

declare module '@shopify/flash-list/AnimatedFlashList' {
	import { Animated } from "react-native";
	import { FlashListProps } from "@shopify/flash-list/FlashListProps";
	const AnimatedFlashList: Animated.AnimatedComponent<import("react").ComponentType<FlashListProps<any>>>;
	export default AnimatedFlashList;
}

declare module '@shopify/flash-list/native/auto-layout/AutoLayoutView' {
	import React, { ReactNode } from "react";
	import { LayoutChangeEvent } from "react-native";
	export type BlankAreaEventHandler = (blankAreaEvent: BlankAreaEvent) => void;
	export const useOnNativeBlankAreaEvents: (onBlankAreaEvent: (blankAreaEvent: BlankAreaEvent) => void) => void;
	export interface BlankAreaEvent {
		offsetStart: number;
		offsetEnd: number;
		blankArea: number;
	}
	export interface AutoLayoutViewProps {
		children?: ReactNode;
		onBlankAreaEvent?: BlankAreaEventHandler;
		onLayout?: (event: LayoutChangeEvent) => void;
		disableAutoLayout?: boolean;
	}
	class AutoLayoutView extends React.Component<AutoLayoutViewProps> {
		render(): JSX.Element;
	}
	export default AutoLayoutView;
}

declare module '@shopify/flash-list/benchmark/useBenchmark' {
	import React from "react";
	import FlashList from "@shopify/flash-list/FlashList";
	import { JSFPSResult } from "@shopify/flash-list/benchmark/JSFPSMonitor";
	import { BlankAreaTrackerResult } from "@shopify/flash-list/benchmark/useBlankAreaTracker";
	export interface BenchmarkParams {
			startDelayInMs?: number;
			/**
				* Can be used to increase or decrease speed of scrolling
				*/
			speedMultiplier?: number;
			/**
				* Specify the number of times benchmark should repeat itself
				*/
			repeatCount?: number;
			/**
				* When set to true, cumulative blank area will include sum of negative blank area values
				* Blank area is negative when list is able to draw faster than the scroll speed.
				*/
			sumNegativeBlankAreaValues?: boolean;
	}
	export interface BenchmarkResult {
			js?: JSFPSResult;
			interrupted: boolean;
			suggestions: string[];
			blankArea?: BlankAreaTrackerResult;
			formattedString?: string;
	}
	/**
		* Runs the benchmark on FlashList.
		* Response object has a formatted string that can be printed to the console or shown as an alert.
		* Result is posted to the callback method passed to the hook.
		*/
	export function useBenchmark(flashListRef: React.RefObject<FlashList<any>>, callback: (benchmarkResult: BenchmarkResult) => void, params?: BenchmarkParams): ((event: import("..").BlankAreaEvent) => void)[];
	export function getFormattedString(res: BenchmarkResult): string;
}

declare module '@shopify/flash-list/benchmark/useDataMultiplier' {
	/**
	  * Increases the data size by duplicating it, it's kept in hook format so that in future we can add auto pagination support.
	  * If you're using this with FlatList then make sure you remove `keyExtractor` because this method might duplicate ids that might be in the data.
	  * @param data The data to duplicate
	  * @param count Final count of data to be returned from this hook
	  * @returns Multiplied data.
	  */
	export function useDataMultiplier<T>(data: T[], count: number): [T[]];
}

declare module '@shopify/flash-list/benchmark/useFlatListBenchmark' {
	import { FlatList } from "react-native";
	import { BenchmarkParams, BenchmarkResult } from "@shopify/flash-list/benchmark/useBenchmark";
	export interface FlatListBenchmarkParams extends BenchmarkParams {
		targetOffset: number;
	}
	/**
	  * Runs the benchmark on FlatList and calls the callback method with the result.
	  * Target offset is mandatory in params.
	  * It's recommended to remove pagination while running the benchmark. Removing the onEndReached callback is the easiest way to do that.
	  */
	export function useFlatListBenchmark(flatListRef: React.RefObject<FlatList<any>>, callback: (benchmarkResult: BenchmarkResult) => void, params: FlatListBenchmarkParams): never[];
}

declare module '@shopify/flash-list/benchmark/useBlankAreaTracker' {
	import React from "react";
	import { BlankAreaEvent } from "@shopify/flash-list/native/auto-layout/AutoLayoutView";
	import FlashList from "@shopify/flash-list/FlashList";
	export interface BlankAreaTrackerResult {
			/**
				* Max blank area displayed
				*/
			maxBlankArea: number;
			/**
				* Sum of all blank area values across all frames
				*/
			cumulativeBlankArea: number;
	}
	export interface BlankAreaTrackerConfig {
			/**
				* When set to true the hook will also sum all negative blank area values.
				* Blank area is negative when list is able to draw faster than the scroll speed.
				*/
			sumNegativeValues?: boolean;
			/**
				* By default, the hook ignores blank events for 1s after the list load. This value can be changed using this parameter.
				* Please note that this duration kicks in after the list has loaded and not after the first scroll.
				*/
			startDelayInMs?: number;
	}
	/**
		* Can be used to track visible blank area in production
		* @param flashListRef Ref to the FlashList component
		* @param onBlankAreaChange This event handler will be called when the blank area changes
		* @param config additional configuration for the blank area tracker
		* @returns blankAreaTrackerResult - maxBlankArea, cumulativeBlankArea this object is mutated and kept up to date. Also returns a callback that needs to be forwarded to FlashList.
		*/
	export function useBlankAreaTracker(flashListRef: React.RefObject<FlashList<any>>, onBlankAreaChange?: (value: BlankAreaTrackerResult) => void, config?: BlankAreaTrackerConfig): [BlankAreaTrackerResult, (event: BlankAreaEvent) => void];
}

declare module '@shopify/flash-list/MasonryFlashList' {
	import React from "react";
	import { NativeScrollEvent } from "react-native";
	import FlashList from "@shopify/flash-list/FlashList";
	import { FlashListProps, ListRenderItemInfo } from "@shopify/flash-list/FlashListProps";
	export interface MasonryListRenderItemInfo<TItem> extends ListRenderItemInfo<TItem> {
			columnSpan: number;
			columnIndex: number;
	}
	export type MasonryListRenderItem<TItem> = (info: MasonryListRenderItemInfo<TItem>) => React.ReactElement | null;
	export interface MasonryFlashListProps<T> extends Omit<FlashListProps<T>, "horizontal" | "initialScrollIndex" | "inverted" | "onBlankArea" | "renderItem" | "viewabilityConfigCallbackPairs"> {
			/**
				* Allows you to change the column widths of the list. This is helpful if you want some columns to be wider than the others.
				* e.g, if `numColumns` is `3`, you can return `2` for `index 1` and `1` for the rest to achieve a `1:2:1` split by width.
				*/
			getColumnFlex?: (items: MasonryListItem<T>[], columnIndex: number, maxColumns: number, extraData?: any) => number;
			/**
				* If enabled, MasonryFlashList will try to reduce difference in column height by modifying item order.
				* `overrideItemLayout` is required to make this work.
				*/
			optimizeItemArrangement?: boolean;
			/**
				* Extends typical `renderItem` to include `columnIndex` and `columnSpan` (number of columns the item spans).
				* `columnIndex` gives the consumer column information in case they might need to treat items differently based on column.
				* This information may not otherwise be derived if using the `optimizeItemArrangement` feature, as the items will no
				* longer be linearly distributed across the columns; instead they are allocated to the column with the least estimated height.
				*/
			renderItem: MasonryListRenderItem<T> | null | undefined;
	}
	export interface MasonryFlashListScrollEvent extends NativeScrollEvent {
			doNotPropagate?: boolean;
	}
	export interface MasonryListItem<T> {
			originalIndex: number;
			originalItem: T;
	}
	/**
		* MasonryFlashListRef with support for scroll related methods
		*/
	export interface MasonryFlashListRef<T> {
			scrollToOffset: FlashList<T>["scrollToOffset"];
			scrollToEnd: FlashList<T>["scrollToEnd"];
			getScrollableNode: FlashList<T>["getScrollableNode"];
	}
	/**
		* FlashList variant that enables rendering of masonry layouts.
		* If you want `MasonryFlashList` to optimize item arrangement, enable `optimizeItemArrangement` and pass a valid `overrideItemLayout` function.
		*/
	export const MasonryFlashList: <T>(props: MasonryFlashListProps<T> & {
			ref?: React.RefObject<MasonryFlashListRef<T>> | undefined;
	}) => React.ReactElement;
}

declare module '@shopify/flash-list/benchmark/JSFPSMonitor' {
	/**
	  * Can be used to monitor JS thread performance
	  * Use startTracking() and stopAndGetData() to start and stop tracking
	  */
	export class JSFPSMonitor {
		startTracking(): void;
		stopAndGetData(): JSFPSResult;
	}
	export interface JSFPSResult {
		minFPS: number;
		maxFPS: number;
		averageFPS: number;
	}
}

declare module '@shopify/flash-list/benchmark/AutoScrollHelper' {
	/**
	  * This method can be used to trigger scroll events that can be forwarded to an element. Anything that implements scrollable can leverage this.
	  * @param scroll The scrollable element
	  * @param fromX The x offset to start from
	  * @param fromY The y offset to start from
	  * @param toX the x offset to end scroll at
	  * @param toY the y offset to end scroll at
	  * @param speedMultiplier  the speed multiplier to use
	  * @param cancellable can be used to cancel the scroll
	  * @returns Promise that resolves when the scroll is complete
	  */
	export function autoScroll(scroll: (x: number, y: number, animated: boolean) => void, fromX: number, fromY: number, toX: number, toY: number, speedMultiplier?: number, cancellable?: Cancellable): Promise<boolean>;
	export class Cancellable {
		cancel(): void;
		isCancelled(): boolean;
		_isCancelled: boolean;
	}
}

declare module '@shopify/flash-list/viewability/ViewToken' {
	export default interface ViewToken {
		item: any;
		key: string;
		index: number | null;
		isViewable: boolean;
		timestamp: number;
	}
}

declare module '@shopify/flash-list/native/cell-container/CellContainer' {
	import React from "react";
	import { ViewProps } from "react-native";
	export interface CellContainerProps extends ViewProps {
		index: number;
	}
	const CellContainer: React.ForwardRefExoticComponent<CellContainerProps & React.RefAttributes<unknown>>;
	export default CellContainer;
}

declare module '@shopify/flash-list/GridLayoutProviderWithProps' {
	import { Dimension, GridLayoutProvider, Layout, LayoutManager } from "recyclerlistview";
	import { FlashListProps } from "@shopify/flash-list/FlashListProps";
	export default class GridLayoutProviderWithProps<T> extends GridLayoutProvider {
			defaultEstimatedItemSize: number;
			constructor(maxSpan: number, getLayoutType: (index: number, props: FlashListProps<T>, mutableLayout: {
					span?: number;
					size?: number;
			}) => string | number, getSpan: (index: number, props: FlashListProps<T>, mutableLayout: {
					span?: number;
					size?: number;
			}) => number, getHeightOrWidth: (index: number, props: FlashListProps<T>, mutableLayout: {
					span?: number;
					size?: number;
			}) => number | undefined, props: FlashListProps<T>, acceptableRelayoutDelta?: number);
			updateProps(props: FlashListProps<T>): GridLayoutProviderWithProps<T>;
			/**
				* This methods returns true if the layout provider has expired and needs to be recreated.
				* This can happen if the number of columns has changed or the render window size has changed in a way that cannot be handled by the layout provider internally.
				*/
			get hasExpired(): boolean;
			/**
				* Calling this method will mark the layout provider as expired. As a result, a new one will be created by FlashList and old cached layouts will be discarded.
				*/
			markExpired(): void;
			/**
				* Calling this method will help the layout provider track average item sizes on its own
				* Overriding layout manager can help achieve the same thing without relying on this method being called however, it will make implementation very complex for a simple use case
				* @param index Index of the item being reported
				*/
			reportItemLayout(index: number): void;
			get averageItemSize(): number;
			newLayoutManager(renderWindowSize: Dimension, isHorizontal?: boolean, cachedLayouts?: Layout[]): LayoutManager;
	}
}

